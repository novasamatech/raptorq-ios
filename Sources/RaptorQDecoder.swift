//
//  RaptorQDecoder.swift
//  Swift-friendly wrapper around the C API that now uses `void *`
//

import raptorq      // <-- module generated by the XCFramework / podspec
import Foundation

/// Safe, convenience API for streaming-QR RaptorQ decoding.
public final class RaptorQDecoder {

    // MARK: Stored properties
    private var ctx: UnsafeMutableRawPointer     // opaque C handle

    // MARK: Initialisation ----------------------------------------------------

    /// Create a fresh decoder when you already know the total length
    /// and the max payload of each QR frame.
    public init?(totalBytes: UInt64, maxPayload: UInt16) {
        guard let raw = raptorq_ctx_new(totalBytes, maxPayload) else { return nil }
        self.ctx = raw
    }

    /// Create a decoder from the 12-byte OTI header embedded in the first QR.
    public convenience init?(oti12 data: Data) {
        guard data.count == 12 else { return nil }
        let maybeCtx = data.withUnsafeBytes { buf in
            raptorq_ctx_from_oti(buf.bindMemory(to: UInt8.self).baseAddress)
        }
        guard let raw = maybeCtx else { return nil }
        self.init(wrapping: raw)
    }

    /// Private designated initialiser used by the convenience one above.
    private init(wrapping raw: UnsafeMutableRawPointer) { self.ctx = raw }

    deinit { raptorq_ctx_free(ctx) }

    // MARK: Feeding packets ---------------------------------------------------

    /// Push one QR-frame payload.
    /// - Returns: `true` if decoding completed with this packet.
    @discardableResult
    public func push(frame payload: Data) -> Bool {
        payload.withUnsafeBytes { buf in
            raptorq_ctx_push_frame(
                ctx,
                buf.bindMemory(to: UInt8.self).baseAddress,
                buf.count
            )
        }
    }

    /// `true` once enough packets have been received to reconstruct the object.
    public var isComplete: Bool { raptorq_ctx_is_complete(ctx) }

    // MARK: Taking the result -------------------------------------------------

    /// Move the reconstructed object out of Rust and into a Swift `Data`.
    /// Call **once**. Subsequent calls return `nil`.
    public func takeResult() -> Data? {
        guard isComplete else { return nil }

        var length = 0
        guard let rawBuf = raptorq_ctx_take_result(ctx, &length) else { return nil }

        // Wrap without copy; free via raptorq_free when Data is released.
        return Data(bytesNoCopy: rawBuf,
                    count: length,
                    deallocator: .custom { ptr, len in
                        raptorq_free(ptr.assumingMemoryBound(to: UInt8.self), len)
                    })
    }
}